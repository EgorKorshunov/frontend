import { ROSI_GAME_MAX_DURATION_SEC } from 'constants/RosiGame';
import * as PIXI from 'pixi.js';
import { calcPercent, isMobileRosiGame } from './utils';

export class CoinAnimation {
  constructor(app) {
    this.app = app;
    this.container = new PIXI.Container();

    this.trajectory = new PIXI.Graphics();
    this.container.addChild(this.trajectory);

    this.elonAndCoin = new PIXI.Container();
    this.container.addChild(this.elonAndCoin);

    this.coin = new PIXI.Sprite(this.app.loader.resources.coin.texture);
    this.elonAndCoin.addChild(this.coin);

    this.xSegments = [];

    const spritesheet =
      this.app.loader.resources['elon-coin-animation'].spritesheet;
    this.elon = new PIXI.AnimatedSprite(Object.values(spritesheet.textures));
    this.elon.x = -92 / (isMobileRosiGame ? 2 : 1);
    this.elon.y = -111 / (isMobileRosiGame ? 2 : 1);
    this.elonAndCoin.addChild(this.elon);

    this.elonAndCoindAnimationHandle = null;
    this.elonAfterExplosionAnimationHandle = null;

    this.setCoinDefaultPosition();

    this.container.visible = false;
  }

  getCurrentElonFrame() {
    return this.elon.currentFrame;
  }

  getElonFramesCount() {
    return this.elon.totalFrames;
  }

  advanceElonAnim() {
    if (this.elon.currentFrame + 1 < this.elon.totalFrames) {
      this.elon.gotoAndStop(this.elon.currentFrame + 1);
    }
  }

  setElonFrame(frame) {
    if (frame <= this.elon.totalFrames) {
      this.elon.gotoAndStop(frame);
    }
  }

  setCoinDefaultPosition() {
    this.elonAndCoin.scale.set(1);
    this.elonAndCoin.x = 0;
    this.elonAndCoin.y = this.app.renderer.height - this.coin.height / 2;
  }

  getCoinExplosionPosition() {
    const coinGlobalPos = this.coin.toGlobal(this.coin.position);
    return {
      x: coinGlobalPos.x + this.coin.width / 2,
      y: coinGlobalPos.y + this.coin.height / 2,
    };
  }

  getCoinCrashPosition() {
    const coinGlobalPos = this.coin.toGlobal(this.coin.position);
    return {
      x: coinGlobalPos.x,
      y: coinGlobalPos.y + this.coin.height,
    };
  }

  startCoinFlyingAnimation() {
    this.container.visible = true;
    this.resetAllAnimations();
    this.setCoinDefaultPosition();

      this.prevCrashFactor = 1;
      this.prevElapsedTime = 0;
      this.incCount = 0;

    /* Coin and Elon */
    // const destX = calcPercent(this.app.renderer.width, 90);
    // const destY = calcPercent(this.app.renderer.height, 35);
    this.destX = this.app.renderer.width;
    this.destY = 0;
    const distanceX = this.destX - this.elonAndCoin.x;
    const distanceY = this.destY - this.elonAndCoin.y;
    const length = Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2));
    const vx = distanceX / length;
    const vy = distanceY / length;
    const defaultSpeed = length / (ROSI_GAME_MAX_DURATION_SEC * 100);
    // start with higher speed for the boost effect
    // let speed = defaultSpeed * 170;
    let speed = 0;
    this.elonAndCoin.x = this.destX - this.elonAndCoin.width * 1.5;
    this.elonAndCoin.y = this.elonAndCoin.height /2;

    // save for later elon flying animation after coin explosion
    this.elonAndCoin.vx = vx;
    this.elonAndCoin.vy = vy;
    this.elonAndCoin.speed = speed;
    this.elonAndCoin.defaultSpeed = defaultSpeed;
  }

  update(dt, elapsedTime, crashFactor) {
    const vx = this.elonAndCoin.vx;
    const vy = this.elonAndCoin.vy;
    const defaultSpeed = this.elonAndCoin.defaultSpeed;
    const coinPos = this.getCoinCrashPosition();
    this.elonAndCoin.visible = false;

    if (this.elonAndCoin.x < this.destX || this.elonAndCoin.y > this.destY) {
      this.elonAndCoin.x += vx * this.elonAndCoin.speed * dt;
      this.elonAndCoin.y += vy * this.elonAndCoin.speed * dt;
    }

    // let x = 0;
    // let y = this.app.renderer.height - (1 * this.app.renderer.height) / 10;

    const startX = 0;
    const startY = this.app.renderer.height;

    // console.log(elapsedTime, crashFactor);

    // x += vx * this.elonAndCoin.speed * dt;
    // y += vy * this.elonAndCoin.speed * dt;
    // x = calcX(elapsedTime, crashFactor, crashFactor, 1);
    // y = calcY(elapsedTime, crashFactor, elapsedTime, 1);

    // this.trajectory.lineStyle(2, 0x7300d8, 1);
    // this.trajectory.moveTo(this.prev_x || startX, this.prev_y || startY);
    // this.trajectory.lineTo(x, this.app.renderer.height - y);
    // this.trajectory.scale.set(scaleX, scaleY);

    // this.prev_x = x;
    // this.prev_y = this.app.renderer.height - y;

    // if (!this.drawn) {
    //   this.trajectory.bezierCurveTo(
    //     this.app.renderer.width,
    //     this.app.renderer.height,
    //     this.app.renderer.width,
    //     this.app.renderer.height - ((10 - 1) * this.app.renderer.height) / (10 - 1),
    //     this.app.renderer.width,
    //     this.app.renderer.height - ((10 - 1) * this.app.renderer.height) / (10 - 1),
    //   )

    //   this.drawn = true;
    // }

    // if (this.elonAndCoin.speed > defaultSpeed) {
    //   this.elonAndCoin.speed -= defaultSpeed * 2.5 * dt; // 8 is a magic number...
    // } else {
    //   // this.elonAndCoin.speed = defaultSpeed;
    //   this.elonAndCoin.speed = 0;
    // }

    const segments = Math.trunc((crashFactor - 1) * 100);
    // const prevX = this.prevX || 0;
    // const prevY = this.prevY || this.app.renderer.height;
    const x = elapsedTime;
    const y = this.app.renderer.height - crashFactor;


    if (crashFactor - this.prevCrashFactor >= 0.01) {
      this.xSegments.push(elapsedTime);
      this.prevCrashFactor = crashFactor;
    }

    const colors = [0x7300d8, 0x7300d8];
    this.trajectory.clear();
    const scaleY = coinPos.y / (crashFactor - 1);
    let prevX = 0;
    let prevY = this.app.renderer.height;

    if (this.xSegments.length === 0) {
      return;
    }

    for (let i = 0; i < segments; i++) {
      const segmentTime = this.xSegments[i];
      const segmentWidth = elapsedTime / segments;
      // const y = this.app.renderer.height - calcPercent(coinPos.y, ((i * 0.01) * 100) / crashFactor);
      // const x = calcPercent(coinPos.x, ((segmentTime * 100) / (elapsedTime + 1)));
      const Pcy = (crashFactor - 1) / 2;
      const Pcx = 0;
      const sw = this.app.renderer.width;
      const scaleX = (coinPos.x) / (-1);
      const y = coinPos.y / 2 - ((1 + i * 0.01) - Pcy) * scaleY + scaleY;

      const percentX = (segmentTime) * 100 / (elapsedTime);
      // const percentX = ((i + segmentTime) * 100) / (Math.max(elapsedTime + 5, 0.1));
      const x = calcPercent(this.app.renderer.width / 2, percentX);

      // const percentY = (1 + (segments - i) * 0.01) * 100 / crashFactor;
      // const y = calcPercent(this.app.renderer.height, percentY);
      // const scaleY = this.app.renderer.height / (crashFactor - 1);
      // const y = this.app.renderer.height / 2 - ((segments - i) * 0.01 - 0) * scaleY + scaleY;
      
      if (i === 0) {
        console.log(`
          x: ${x}
          y: ${y}
          percentX: ${percentX}
          elapsedTime: ${elapsedTime}
          crashFactor: ${crashFactor}
          segments: ${segments}
          segmentTime: ${segmentTime}
          segmentWidth: ${segmentWidth}
        `)
      }

      this.trajectory.lineStyle(4, colors[Math.floor(i % 2)], 1);
      this.trajectory.moveTo(prevX, prevY);
      this.trajectory.lineTo(x, y);

      prevX = x;
      prevY = y;
    }

    this.prevX = x;
    this.prevY = y;
    return;

    if (crashFactor - this.prevCrashFactor >= 0.01) {
      const segments = (crashFactor - 1) * 100;
      // console.log(crashFactor, elapsedTime, crashFactor - this.prevCrashFactor)

      const prevX = this.prevElapsedTime;
      const prevY = crashFactor;
      const x = elapsedTime;
      const y = crashFactor;

      const sw = coinPos.x;
      const sh = this.app.renderer.height - coinPos.y;

      const scaleX = sw * 2 / (-elapsedTime - x);
      const scaleY = sh / (crashFactor - 1);
      const Pcx = 0;
      const Pcy = (crashFactor - 1) / 2;

      const oldX = sw / 2 + (-prevX - Pcx) * scaleX - coinPos.x / 2;
      const oldY = sh / 2 - (prevY - Pcy) * scaleY + scaleY + coinPos.y;
      const newX = sw / 2 + (-x - Pcx) * scaleX - coinPos.x / 2;
      const newY = sh / 2 - (y - Pcy) * scaleY + scaleY + coinPos.y;

      this.trajectory.clear();
      this.trajectory.lineStyle(2, 0x7300d8, 1);
      this.trajectory.moveTo(0, this.app.renderer.height);
      this.trajectory.lineTo(newX, newY);

      this.prevCrashFactor = crashFactor;
      this.prevElapsedTime = elapsedTime;
    }
  }

  endCoinFlyingAnimation() {
    if (this.elonAndCoindAnimationHandle) {
      this.app.ticker.remove(this.elonAndCoindAnimationHandle);
      this.elonAndCoindAnimationHandle = null;
    }

    this.coin.alpha = 0;
    this.elon.alpha = 0;
  }

  startElonAfterExplosionAnimation() {
    // const rotationSpeed = 0.005;
    // For the sake of simplicty animate elonAndCoin container instead of just elon.
    // Coin is hidden anyway and positions are already being reset before next animation.
    // const update = dt => {
    //   this.elonAndCoin.rotation += rotationSpeed * dt;
    //   this.elonAndCoin.x += this.elonAndCoin.vx * this.elonAndCoin.speed * dt;
    //   this.elonAndCoin.y += this.elonAndCoin.vy * this.elonAndCoin.speed * dt;
    // };
    // this.elonAfterExplosionAnimationHandle = update;
    // this.app.ticker.add(update);
  }

  resetAllAnimations() {
    if (this.elonAndCoindAnimationHandle) {
      this.app.ticker.remove(this.elonAndCoindAnimationHandle);
      this.elonAndCoindAnimationHandle = null;
    }

    if (this.elonAfterExplosionAnimationHandle) {
      this.app.ticker.remove(this.elonAfterExplosionAnimationHandle);
      this.elonAfterExplosionAnimationHandle = null;
    }

    this.coin.alpha = 1;
    this.elon.alpha = 1;
    this.elonAndCoin.rotation = 0;
    this.elon.gotoAndStop(0);
    // this.trajectory.clear();
  }

  getCurrentVelocty() {
    return {
      x: this.elonAndCoin.vx,
      y: this.elonAndCoin.vy,
    };
  }
}
